<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="categories">
<meta property="og:url" content="http://blog.fxti.xyz/categories/index.html">
<meta property="og:site_name" content="FXTi&#39;s blog">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-28T16:40:56.663Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="categories">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.fxti.xyz/categories/">





  <title>加密学-学校课程内容 | FXTi's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FXTi's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.fxti.xyz/2019/12/03/Crypto-School/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FX-Ti">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FXTi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">加密学-学校课程内容</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T14:36:17+08:00">2019-12-03</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="学校课程设涉及到的加密学算法实现"><a href="#学校课程设涉及到的加密学算法实现" class="headerlink" title="学校课程设涉及到的加密学算法实现"></a>学校课程设涉及到的加密学算法实现</h1><p>学校内容的加密学报告备份</p>
<a id="more"></a>
<h1 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h1><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>凯撒密码是一种但表带换密码，因为罗马共和时期的凯撒曾用这种方法加密与将领们的信息而得名。狭义上，恺撒密码特指偏移量为3的情况。广义上，恺撒密码可以指所有在字母表上向后（或向前）按照一个固定数目进行偏移的密码。</p>
<p>举个例子当偏移量为+3时，A会变成D,C会变成F，等等。</p>
<img src="/2019/12/03/Crypto-School/F4qz6S.png">
<h3 id="加密实现"><a href="#加密实现" class="headerlink" title="加密实现"></a>加密实现</h3><p>首先计算机实现中每个字符都有对应的码值，在<code>Python</code>中可以用<code>ord()</code>函数得到字符对应的<strong>ASCII</strong>码值。</p>
<p>可以得到加密的公式为：$c_i = (m_i + j) mod 26$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(m, k)</span>:</span></span><br><span class="line">    k %= <span class="number">26</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(m)):</span><br><span class="line">        <span class="keyword">if</span> m[i].isupper():</span><br><span class="line">            res += chr((ord(m[i])-ord(<span class="string">'A'</span>)+k)%<span class="number">26</span>+ord(<span class="string">'A'</span>))</span><br><span class="line">        <span class="keyword">elif</span> m[i].islower():</span><br><span class="line">            res += chr((ord(m[i])-ord(<span class="string">'a'</span>)+k)%<span class="number">26</span>+ord(<span class="string">'a'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += m[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="解密实现"><a href="#解密实现" class="headerlink" title="解密实现"></a>解密实现</h3><p>解密过程就是加密过程的逆运算，对应公式为：$m_i = (c_i - k + 26) mod 26$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c,k)</span>:</span></span><br><span class="line">    k %= <span class="number">26</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">        <span class="keyword">if</span> c[i].isupper():</span><br><span class="line">            res += chr((ord(c[i])-ord(<span class="string">'A'</span>)+<span class="number">26</span>-k)%<span class="number">26</span>+ord(<span class="string">'A'</span>))</span><br><span class="line">        <span class="keyword">elif</span> c[i].islower():</span><br><span class="line">            res += chr((ord(c[i])-ord(<span class="string">'a'</span>)+<span class="number">26</span>-k)%<span class="number">26</span>+ord(<span class="string">'a'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += c[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="针对凯撒的攻击"><a href="#针对凯撒的攻击" class="headerlink" title="针对凯撒的攻击"></a>针对凯撒的攻击</h3><h4 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h4><p>因为可能的偏移值仅有25种，完全可以直接枚举得到所有可能性，然后人工分辨的到其中正确的明文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bruteforce</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">		<span class="keyword">print</span> decrypt(c, i)</span><br></pre></td></tr></table></figure>
<h3 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>即使对于唯密文攻击，凯撒密码也因为偏移值的取值空间过小而非常容易破解。对于密文规模较大的可以直接让计算机基于字典来选取25中可能性较大的情况来直接得到可用的偏移值完成破解。</p>
<h2 id="仿射密码"><a href="#仿射密码" class="headerlink" title="仿射密码"></a>仿射密码</h2><p>仿射密码和凯撒密码同属于单表代换密码，但相对于凯撒密码的简单位移，仿射密码构成了一个线性方程来完成明文到密文的变换。</p>
<h3 id="加密实现-1"><a href="#加密实现-1" class="headerlink" title="加密实现"></a>加密实现</h3><p>仿射密码的加密过程表达成公式：$c_i = (k_1 * m_i + k_2) mod 26$,要求$k_1$和26互素，即$gcd(k_1, 26) = 1$。实际上仅有满足这个条件时，$|C| = |M|$，否则对于同一个密文会有多个明文对应，使得从密文得到明文的过程无法完成。</p>
<p>判断最大公约数可使用辗转相除法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a%b)</span><br></pre></td></tr></table></figure>
<p>然后完成加密代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(m, k1, k2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> gcd(k1, <span class="number">26</span>) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(m)):</span><br><span class="line">        <span class="keyword">if</span> m[i].isupper():</span><br><span class="line">            res.append(chr((k1*(ord(m[i])-ord(<span class="string">'A'</span>))+k2)%<span class="number">26</span>+ord(<span class="string">'A'</span>)))</span><br><span class="line">        <span class="keyword">elif</span> m[i].islower():</span><br><span class="line">            res.append(chr((k1*(ord(m[i])-ord(<span class="string">'a'</span>))+k2)%<span class="number">26</span>+ord(<span class="string">'a'</span>)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(m[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="解密实现-1"><a href="#解密实现-1" class="headerlink" title="解密实现"></a>解密实现</h3><p>根据加密公式可得到解密公式：$m_i = k_1^{-1} * (c_i - k_2) mod 26$，该过程中值得一提的是$k_1^{-1}$这个值的计算过程。这里选用拓展欧几里得求逆元：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exgcdInv</span><span class="params">(a,m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> gcd(a,m)!=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    u1,u2,u3 = <span class="number">1</span>,<span class="number">0</span>,a</span><br><span class="line">    v1,v2,v3 = <span class="number">0</span>,<span class="number">1</span>,m</span><br><span class="line">    <span class="keyword">while</span> v3!=<span class="number">0</span>:</span><br><span class="line">        q = u3//v3</span><br><span class="line">        v1,v2,v3,u1,u2,u3 = (u1-q*v1),(u2-q*v2),(u3-q*v3),v1,v2,v3</span><br><span class="line">    <span class="keyword">return</span> u1%m</span><br></pre></td></tr></table></figure>
<p>然后可以得到解密函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c, k1, k2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> gcd(k1, <span class="number">26</span>) != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    k1 = exgcdInv(k1, <span class="number">26</span>)</span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">        <span class="keyword">if</span> c[i].isupper():</span><br><span class="line">            res += chr((k1*(ord(c[i])-ord(<span class="string">'A'</span>)+<span class="number">26</span>-k2))%<span class="number">26</span>+ord(<span class="string">'A'</span>))</span><br><span class="line">        <span class="keyword">elif</span> c[i].islower():</span><br><span class="line">            res += chr((k1*(ord(c[i])-ord(<span class="string">'a'</span>)+<span class="number">26</span>-k2))%<span class="number">26</span>+ord(<span class="string">'a'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += c[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="针对仿射的攻击"><a href="#针对仿射的攻击" class="headerlink" title="针对仿射的攻击"></a>针对仿射的攻击</h3><h4 id="穷举攻击"><a href="#穷举攻击" class="headerlink" title="穷举攻击"></a>穷举攻击</h4><p>对于密文暴力枚举出所有的可能组合(共$\phi(26) * 26 - 1 = 311$种 )然后从中选出有意义的正确明文。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bruteforce</span><span class="params">(c)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">		<span class="keyword">if</span> gcd(i, <span class="number">26</span>) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                print(decrypt(c, i, j))</span><br></pre></td></tr></table></figure>
<h4 id="统计分析攻击"><a href="#统计分析攻击" class="headerlink" title="统计分析攻击"></a>统计分析攻击</h4><p>再截取密文足够长的情况下，因为明文和密文一一对应的关系，明文中所呈现的自然语言规律也会体现在密文中。</p>
<p>于是首先对于密文中出现的所有字符个数进行统计并排序，按照自然语言规律中的出现次序进行匹配和对应的解密然后从中选取合理的解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,ch,cnt)</span>:</span></span><br><span class="line">        self.ch = ch</span><br><span class="line">        self.cnt = cnt</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self,other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.cnt &gt; other.cnt</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">static</span><span class="params">(c)</span>:</span></span><br><span class="line">    cLower = c.lower()</span><br><span class="line">    alphaNum = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        t = Node(chr(ord(<span class="string">'a'</span>)+i),<span class="number">0</span>)</span><br><span class="line">        alphaNum.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">        <span class="keyword">if</span> cLower[i].isalpha():</span><br><span class="line">            alphaNum[ord(ciperCopy[i])-ord(<span class="string">'a'</span>)].cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    alphaNum.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        <span class="keyword">if</span> gcd(i,<span class="number">26</span>) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                <span class="keyword">if</span> chr((<span class="number">4</span>*i+j)%<span class="number">26</span>+ord(<span class="string">'a'</span>)) == alphaNum[<span class="number">0</span>].ch:</span><br><span class="line">                    print(decrypt(c,i,j))</span><br></pre></td></tr></table></figure>
<h3 id="安全性分析-1"><a href="#安全性分析-1" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>因为密钥空间根据之前的计算仅311种，对于穷举攻击来说轻而易举，更何况统计攻击。所以在现代视角看来仿射密码的安全性极弱。</p>
<h2 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h2><p>之前的密码都是单表替换密码，由于密钥空间过小而容易被破解。维吉尼亚密码则是多表替换密码，在同一段密码上使用多个替换过程来抗攻击。</p>
<p>对应的替换关系根据这一位对应的密钥所决定，公式：$c_i = (m_i + k_i) mod 26$，对应关系如图：</p>
<img src="/2019/12/03/Crypto-School/F5nUKS.png">
<h3 id="加密实现-2"><a href="#加密实现-2" class="headerlink" title="加密实现"></a>加密实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m = input()</span><br><span class="line">k = input().lower()</span><br><span class="line"></span><br><span class="line">m = list(map(<span class="keyword">lambda</span> x: (ord(x) - ord(<span class="string">'A'</span>), <span class="string">'A'</span>) <span class="keyword">if</span> <span class="string">'A'</span> &lt;= x &lt;= <span class="string">'Z'</span> <span class="keyword">else</span> (ord(x) - ord(<span class="string">'a'</span>), <span class="string">'a'</span>), m))</span><br><span class="line"><span class="comment">#print(m)</span></span><br><span class="line">c = [chr(((m[i][<span class="number">0</span>]+(ord(k[i%len(k)]) - ord(<span class="string">'a'</span>)))%<span class="number">26</span>) + ord(m[i][<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(m))]</span><br><span class="line">print(<span class="string">""</span>.join(c))</span><br></pre></td></tr></table></figure>
<h3 id="解密实现-2"><a href="#解密实现-2" class="headerlink" title="解密实现"></a>解密实现</h3><p>根据加密过程可推：$m_i = (c_i + 26 - k_i)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c,k)</span>:</span></span><br><span class="line">    k = k.upper()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(c)):</span><br><span class="line">        <span class="keyword">if</span> c[i].isupper():</span><br><span class="line">            res += chr(((ord(c[i])-ord(<span class="string">'A'</span>))%<span class="number">26</span>+<span class="number">26</span>-(ord(k[j%len(k)])-ord(<span class="string">'A'</span>))%<span class="number">26</span>)%<span class="number">26</span>+ord(<span class="string">'A'</span>))</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c[i].islower():</span><br><span class="line">            res += chr(((ord(c[i])-ord(<span class="string">'a'</span>))%<span class="number">26</span>+<span class="number">26</span>-(ord(k[j%len(k)])-ord(<span class="string">'A'</span>))%<span class="number">26</span>)%<span class="number">26</span>+ord(<span class="string">'a'</span>))</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += c[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>这里选用重合指数法破解维吉尼亚密码，其也要求有大段的密文来进行统计得到规律。<br>详细过程可以看<a href="virginia.pptx">PPT</a></p>
<blockquote>
<p>重合指数：设某种语言由$n$个字母组成，每个字母i发生的概率为$p_i(1≤i≤n)$，则重合指数就是指两个随机字母相同的概率，记为$IC = \sum_{i=1}^{n}p_i$</p>
<p>一般用$IC$的无偏估计值$IC’$来近似计算$IC$. 其中的$x_i$表示字母$i$出现的频次，$L$表示文本长度，$n$表示某种语言中包含的字母数。$IC’=\sum_{i=1}^{n}\frac{x_i(x_i-1)}{L(L-1)}$</p>
<p>随机英文文本的$IC’$总是大约为0.038.<br>而一段有意义的英文文本的$IC’$总是大约为0.065.</p>
</blockquote>
<p>而维吉尼亚加密是多表加密，则在每一张表加密的密文中仍应该服从自然语言规律。所以可以尝试去分割密文然后统计各张表上对应的密文是否符合规律并猜测得到表的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">c = input().upper()</span><br><span class="line"></span><br><span class="line">res = dict()</span><br><span class="line"><span class="comment">#for i in range(1,len(c)):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,min(<span class="number">128</span>, len(c))):</span><br><span class="line">    tlist = []</span><br><span class="line">    <span class="keyword">for</span> tmp <span class="keyword">in</span> split(c,i):</span><br><span class="line">        alpha = dict()</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            alpha[chr(ord(<span class="string">'A'</span>)+z)] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> tmp:</span><br><span class="line">            alpha[x] += <span class="number">1</span></span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ke <span class="keyword">in</span> alpha.keys():</span><br><span class="line">            acc += alpha[ke] * (alpha[ke] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(tmp) &gt; <span class="number">1</span>:</span><br><span class="line">            tlist.append(acc / (len(tmp) * (len(tmp) - <span class="number">1</span>)))</span><br><span class="line">    <span class="comment">#print(str(i) + " " + str(tlist))</span></span><br><span class="line">    res[i] = sum(tlist) / len(tlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.065</span></span><br><span class="line"></span><br><span class="line">ss = sorted(res.items(), key=<span class="keyword">lambda</span> a: abs(a[<span class="number">1</span>] - <span class="number">0.065</span>))[:<span class="number">10</span>]</span><br><span class="line">pprint.pprint(ss)</span><br></pre></td></tr></table></figure>
<p>之后选取最可能的密钥长度，将密文按照所属的替换表分割，在各组上尝试所有可能偏移，取最符合统计规律的偏移将密文全部解密。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    key_size = int(input(<span class="string">"Choose key size: "</span>))</span><br><span class="line">    off = []</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> split(c, key_size):</span><br><span class="line">        <span class="comment">#print(block)</span></span><br><span class="line">        alpha = dict()</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            alpha[chr(ord(<span class="string">'A'</span>)+z)] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> block:</span><br><span class="line">            alpha[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> alpha.keys():</span><br><span class="line">            alpha[k] /= len(block)</span><br><span class="line">        <span class="comment">#statics is over</span></span><br><span class="line">        ress = dict()</span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">            acc = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> alpha.keys():</span><br><span class="line">                acc += alpha[k] * prob[chr(((ord(k) - ord(<span class="string">'A'</span>) + offset) % <span class="number">26</span>) + ord(<span class="string">'A'</span>))]</span><br><span class="line">            ress[offset] = acc</span><br><span class="line">        pro = sorted(ress.items(), key=<span class="keyword">lambda</span> a: abs(a[<span class="number">1</span>] - <span class="number">0.065</span>))</span><br><span class="line">        off.append(chr(<span class="number">26</span> - pro[<span class="number">0</span>][<span class="number">0</span>] + ord(<span class="string">'a'</span>)))</span><br><span class="line">        key = <span class="string">''</span>.join(off)</span><br><span class="line">    print(key)</span><br><span class="line">    print(<span class="string">''</span>.join(dec(c, key)))</span><br></pre></td></tr></table></figure>
<p>破解效果如下图：</p>
<img src="/2019/12/03/Crypto-School/QzFNxH.png">
<p>给出脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(m, k)</span>:</span></span><br><span class="line">    m = list(map(<span class="keyword">lambda</span> x: (ord(x) - ord(<span class="string">'A'</span>), <span class="string">'A'</span>) <span class="keyword">if</span> <span class="string">'A'</span> &lt;= x &lt;= <span class="string">'Z'</span> <span class="keyword">else</span> (ord(x) - ord(<span class="string">'a'</span>), <span class="string">'a'</span>), m))</span><br><span class="line">    c = [chr(((m[i][<span class="number">0</span>]+(ord(k[i%len(k)]) - ord(<span class="string">'a'</span>)))%<span class="number">26</span>) + ord(m[i][<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(m))]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span><span class="params">(m, k)</span>:</span></span><br><span class="line">    m = list(map(<span class="keyword">lambda</span> x: (ord(x) - ord(<span class="string">'A'</span>), <span class="string">'A'</span>) <span class="keyword">if</span> <span class="string">'A'</span> &lt;= x &lt;= <span class="string">'Z'</span> <span class="keyword">else</span> (ord(x) - ord(<span class="string">'a'</span>), <span class="string">'a'</span>), m))</span><br><span class="line">    c = [chr(((m[i][<span class="number">0</span>]-(ord(k[i%len(k)]) - ord(<span class="string">'a'</span>))+<span class="number">26</span>)%<span class="number">26</span>) + ord(m[i][<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(m))]</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">prob = &#123;</span><br><span class="line">        <span class="string">'A'</span>: <span class="number">0.082</span>,</span><br><span class="line">        <span class="string">'B'</span>: <span class="number">0.015</span>,</span><br><span class="line">        <span class="string">'C'</span>: <span class="number">0.028</span>,</span><br><span class="line">        <span class="string">'D'</span>: <span class="number">0.043</span>,</span><br><span class="line">        <span class="string">'E'</span>: <span class="number">0.127</span>,</span><br><span class="line">        <span class="string">'F'</span>: <span class="number">0.022</span>,</span><br><span class="line">        <span class="string">'G'</span>: <span class="number">0.02</span>,</span><br><span class="line">        <span class="string">'H'</span>: <span class="number">0.061</span>,</span><br><span class="line">        <span class="string">'I'</span>: <span class="number">0.07</span>,</span><br><span class="line">        <span class="string">'J'</span>: <span class="number">0.002</span>,</span><br><span class="line">        <span class="string">'K'</span>: <span class="number">0.008</span>,</span><br><span class="line">        <span class="string">'L'</span>: <span class="number">0.04</span>,</span><br><span class="line">        <span class="string">'M'</span>: <span class="number">0.024</span>,</span><br><span class="line">        <span class="string">'N'</span>: <span class="number">0.067</span>,</span><br><span class="line">        <span class="string">'O'</span>: <span class="number">0.075</span>,</span><br><span class="line">        <span class="string">'P'</span>: <span class="number">0.019</span>,</span><br><span class="line">        <span class="string">'Q'</span>: <span class="number">0.001</span>,</span><br><span class="line">        <span class="string">'R'</span>: <span class="number">0.06</span>,</span><br><span class="line">        <span class="string">'S'</span>: <span class="number">0.063</span>,</span><br><span class="line">        <span class="string">'T'</span>: <span class="number">0.091</span>,</span><br><span class="line">        <span class="string">'U'</span>: <span class="number">0.028</span>,</span><br><span class="line">        <span class="string">'V'</span>: <span class="number">0.01</span>,</span><br><span class="line">        <span class="string">'W'</span>: <span class="number">0.023</span>,</span><br><span class="line">        <span class="string">'X'</span>: <span class="number">0.001</span>,</span><br><span class="line">        <span class="string">'Y'</span>: <span class="number">0.02</span>,</span><br><span class="line">        <span class="string">'Z'</span>: <span class="number">0.001</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(c, i)</span>:</span></span><br><span class="line">    c = list(c)</span><br><span class="line">    <span class="keyword">return</span> [list(map(<span class="keyword">lambda</span> x: c[x], filter(<span class="keyword">lambda</span> x: x % i == j, range(len(c))))) <span class="keyword">for</span> j <span class="keyword">in</span> range(i)]</span><br><span class="line"></span><br><span class="line">c = input().upper()</span><br><span class="line"></span><br><span class="line">res = dict()</span><br><span class="line"><span class="comment">#for i in range(1,len(c)):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,min(<span class="number">128</span>, len(c))):</span><br><span class="line">    tlist = []</span><br><span class="line">    <span class="keyword">for</span> tmp <span class="keyword">in</span> split(c,i):</span><br><span class="line">        alpha = dict()</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            alpha[chr(ord(<span class="string">'A'</span>)+z)] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> tmp:</span><br><span class="line">            alpha[x] += <span class="number">1</span></span><br><span class="line">        acc = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ke <span class="keyword">in</span> alpha.keys():</span><br><span class="line">            acc += alpha[ke] * (alpha[ke] - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> len(tmp) &gt; <span class="number">1</span>:</span><br><span class="line">            tlist.append(acc / (len(tmp) * (len(tmp) - <span class="number">1</span>)))</span><br><span class="line">    <span class="comment">#print(str(i) + " " + str(tlist))</span></span><br><span class="line">    res[i] = sum(tlist) / len(tlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0.065</span></span><br><span class="line"></span><br><span class="line">ss = sorted(res.items(), key=<span class="keyword">lambda</span> a: abs(a[<span class="number">1</span>] - <span class="number">0.065</span>))[:<span class="number">10</span>]</span><br><span class="line">pprint.pprint(ss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    key_size = int(input(<span class="string">"Choose key size: "</span>))</span><br><span class="line">    off = []</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> split(c, key_size):</span><br><span class="line">        <span class="comment">#print(block)</span></span><br><span class="line">        alpha = dict()</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            alpha[chr(ord(<span class="string">'A'</span>)+z)] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> block:</span><br><span class="line">            alpha[x] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> alpha.keys():</span><br><span class="line">            alpha[k] /= len(block)</span><br><span class="line">        <span class="comment">#statics is over</span></span><br><span class="line">        ress = dict()</span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">            acc = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> alpha.keys():</span><br><span class="line">                acc += alpha[k] * prob[chr(((ord(k) - ord(<span class="string">'A'</span>) + offset) % <span class="number">26</span>) + ord(<span class="string">'A'</span>))]</span><br><span class="line">            ress[offset] = acc</span><br><span class="line">        pro = sorted(ress.items(), key=<span class="keyword">lambda</span> a: abs(a[<span class="number">1</span>] - <span class="number">0.065</span>))</span><br><span class="line">        off.append(chr(<span class="number">26</span> - pro[<span class="number">0</span>][<span class="number">0</span>] + ord(<span class="string">'a'</span>)))</span><br><span class="line">        key = <span class="string">''</span>.join(off)</span><br><span class="line">    print(key)</span><br><span class="line">    print(<span class="string">''</span>.join(dec(c, key)))</span><br></pre></td></tr></table></figure>
<h3 id="安全性分析-2"><a href="#安全性分析-2" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>多表代换密码打破了原语言的字符出现规律，故其分析方法比单表代换密码复杂得多。多表代换密码对比单表代换密码安全性显著提高。但是仍然可以用一些统计分析法破解（具体参看上文攻击方法），但是前提是密文足够长。所以，较短的密文几乎是不可破译的。</p>
<h1 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h1><h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><p>RC4 是流密码的一种，突出优点是在软件中容易实现。它可能是世界上使用最广泛的流密码。RC4是WEP中采用的加密算法，也曾经是TLS可采用的算法之一。但在2015年，比利时鲁汶大学的研究人员Mathy Vanhoef及Frank Piessens，公布了针对RC4加密算法的新型攻击程式，可在75小时内取得cookie的内容。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>算法分为两个部分：</p>
<ol>
<li><p>密钥调度算法：根据密钥打乱S盒顺序</p>
</li>
<li><p>伪随机生成算法：根据S盒输出伪随机数序列并更改S盒顺序</p>
</li>
</ol>
<h4 id="密钥调度算法"><a href="#密钥调度算法" class="headerlink" title="密钥调度算法"></a>密钥调度算法</h4><p>根据密钥打乱S盒顺序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *a, <span class="keyword">unsigned</span> <span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *sbox, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> key_len)</span></span>&#123;</span><br><span class="line">	<span class="comment">//sbox should be pointer to 256-bytes space</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> T[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">		sbox[i] = i;</span><br><span class="line">		T[i] = key[i % key_len];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">		j = (j + sbox[i] + T[i]) % <span class="number">256</span>;</span><br><span class="line">		swap(&amp;sbox[i], &amp;sbox[j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="伪随机生成算法"><a href="#伪随机生成算法" class="headerlink" title="伪随机生成算法"></a>伪随机生成算法</h4><p>从 <strong>S</strong> 中随机抽取一个元素输出，并置换 <strong>S</strong> 以便下一次选取，选取的过程取决于索引 <strong>i</strong> 和 <strong>j</strong> ，产生的密文为异或的结果，所以我们在这步就顺便产生密文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_prg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *sbox, <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">unsigned</span> input_len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; input_len; ++z)&#123;</span><br><span class="line">		<span class="comment">//rc4 part starts</span></span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">		j = (j + sbox[i]) % <span class="number">256</span>;</span><br><span class="line">		swap(&amp;sbox[i], &amp;sbox[j]);</span><br><span class="line">		<span class="keyword">unsigned</span> c = sbox[(sbox[i] + sbox[j]) % <span class="number">256</span>];</span><br><span class="line">		<span class="comment">//rc4 part ends</span></span><br><span class="line">		input[z] ^= c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *a, <span class="keyword">unsigned</span> <span class="keyword">char</span> *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *sbox, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> key_len)</span></span>&#123;</span><br><span class="line">	<span class="comment">//sbox should be pointer to 256-bytes space</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> T[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">		sbox[i] = i;</span><br><span class="line">		T[i] = key[i % key_len];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">		j = (j + sbox[i] + T[i]) % <span class="number">256</span>;</span><br><span class="line">		swap(&amp;sbox[i], &amp;sbox[j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4_prg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *sbox, <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">unsigned</span> input_len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; input_len; ++z)&#123;</span><br><span class="line">		<span class="comment">//rc4 part starts</span></span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">		j = (j + sbox[i]) % <span class="number">256</span>;</span><br><span class="line">		swap(&amp;sbox[i], &amp;sbox[j]);</span><br><span class="line">		<span class="keyword">unsigned</span> c = sbox[(sbox[i] + sbox[j]) % <span class="number">256</span>];</span><br><span class="line">		<span class="comment">//rc4 part ends</span></span><br><span class="line">		input[z] ^= c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rc4</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> key_len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *input, <span class="keyword">unsigned</span> input_len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sbox[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	rc4_init(sbox, key, key_len);</span><br><span class="line">	rc4_prg(sbox, input, input_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> message[] = <span class="string">"123456"</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> m_len = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)message);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> key[] = <span class="string">"123456"</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> key_len = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)key);</span><br><span class="line">	rc4(key, key_len, message, m_len);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; m_len; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02x "</span>, message[i]);</span><br><span class="line">	rc4(key, key_len, message, m_len);</span><br><span class="line">	<span class="built_in">puts</span>(message);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>使用123456作为密钥对123456进行加密并解密还原：</p>
<img src="/2019/12/03/Crypto-School/lSJ7PU.png">
<h3 id="正确性分析"><a href="#正确性分析" class="headerlink" title="正确性分析"></a>正确性分析</h3><p>因为加密解密用到的伪随机序列相同，而加密解密算法都是简单的异或运算，异或运算的逆运算仍然是异或运算，所以显然下式成立：$$RC4Decrypt(RC4Encrypt(m,k),k)=m$$</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>RC4 算法容易用软件实现，加解密速度快。需要特别注意的是，为保证安全强度，目前的 RC4 至少要求使用 128 位密钥。</p>
<h2 id="LFSR"><a href="#LFSR" class="headerlink" title="LFSR"></a>LFSR</h2><p>LFSR全程线性反馈移位寄存器，是一种很典型的流密码，在嵌入式设备中经常被使用，因为其硬件实现的效率极高。</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><p>如下：</p>
<img src="/2019/12/03/Crypto-School/lfsr-framework.png">
<p>其中的f函数：</p>
<img src="/2019/12/03/Crypto-School/lfsr-function.png">
<p>对应的生成算法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> lfsr32(<span class="keyword">uint64_t</span> *reg, <span class="keyword">uint64_t</span> mask)&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> result = *reg &amp; <span class="number">0x1</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> tmp = *reg &amp; mask, lastbit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">		tmp &amp;= (tmp - <span class="number">1</span>);</span><br><span class="line">		lastbit ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*reg = (lastbit &lt;&lt; (BITS - <span class="number">1</span>)) | (*reg &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中需要注意的是，LFSR寄存器中的状态空间受限于寄存器位数最大只能达到$2^n-1$，。而且这个最大情况依赖于<code>mask</code>的性质，所以是小于等于的关系。不过平时比赛中的bits均满足该性质，在已知mask的条件下进行解题，但由于之前出现的题目大都可以利用mask的高位得到唯一未知位高速破解，所以这里针对课本的m序列密码进行破译。</p>
<h3 id="m序列密码的破译"><a href="#m序列密码的破译" class="headerlink" title="m序列密码的破译"></a>m序列密码的破译</h3><p>在已知明文攻击下，假设破译者已经知道了2n位明密文对$M=m_1,m_2,…,m_{2n}$,$C=c1,c2,…,c_{2n}$，则可确定2n位长的密钥序列K。并由K推出反馈多项式的系数，从而确定该LFSR接下来的状态并得到余下的密钥序列。</p>
<p>首先由LFSR的计算过程可以得到方程组：</p>
<img src="/2019/12/03/Crypto-School/formula1.png">
<p>可以转换成矩阵求逆求解，以下为脚本使用SMT Solver求解</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># m = 0b011001111111001</span></span><br><span class="line"><span class="comment"># c = 0b101101011110011</span></span><br><span class="line"><span class="comment"># order = 5</span></span><br><span class="line"><span class="comment"># pls solve mask!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># first, calculate key sequence</span></span><br><span class="line">m = <span class="number">0b011001111111001</span></span><br><span class="line">c = <span class="number">0b101101011110011</span></span><br><span class="line">k = m ^ c</span><br><span class="line">k = list(map(int ,bin(k)[<span class="number">2</span>:]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># then, generate equations</span></span><br><span class="line">order = <span class="number">5</span></span><br><span class="line">v = [BitVec(<span class="string">'v%d'</span>%i, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(order)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    Sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        Sum ^= v[j] &amp; k[i+j]</span><br><span class="line">    s.add(k[<span class="number">5</span>+i] == Sum)</span><br><span class="line"></span><br><span class="line">print(s.check())</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure>
<p>可以得到正确的系数。</p>
<h3 id="验证生成序列的周期"><a href="#验证生成序列的周期" class="headerlink" title="验证生成序列的周期"></a>验证生成序列的周期</h3><p>LFSR在抽头选用<strong>本原多项式</strong>时周期达到最大也即$2^n-1$，若要验证周期则随机选择一个非零的寄存器初始状态之后不断迭代检查寄存器是否还原了本来的初始状态。如果在重复之前所迭代的次数不够则说明周期比预期的要小。</p>
<p>整个验证过程中所花费时间最多的是迭代过程，分析一下LFSR的实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> lfsr32(<span class="keyword">uint64_t</span> *reg, <span class="keyword">uint64_t</span> mask)&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> result = *reg &amp; <span class="number">0x1</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> tmp = *reg &amp; mask, lastbit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//loops here</span></span><br><span class="line">	<span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">		lastbit ^= tmp &amp; <span class="number">0x1</span>;</span><br><span class="line">		tmp &gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*reg = (lastbit &lt;&lt; (BITS - <span class="number">1</span>)) | (*reg &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第一种优化"><a href="#第一种优化" class="headerlink" title="第一种优化"></a>第一种优化</h4><p>其中除了循环之外的操作都是常数时间内可以完成的，循环次数在这个写法下最差情况要循环$n-1$次。而优化之后代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> lfsr32(<span class="keyword">uint64_t</span> *reg, <span class="keyword">uint64_t</span> mask)&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> result = *reg &amp; <span class="number">0x1</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> tmp = *reg &amp; mask, lastbit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">		tmp &amp;= (tmp - <span class="number">1</span>);</span><br><span class="line">		lastbit ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*reg = (lastbit &lt;&lt; (BITS - <span class="number">1</span>)) | (*reg &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个优化在于<code>tmp &amp;= (tmp - 1)</code>这个过程，它保证能够去除<code>tmp</code>中从低位开始存在的第一个<code>1</code>。所以只需要循环<code>tmp</code>变量中<code>1</code>出现的次数次即可，检查<strong>Xilinx</strong>给出的LFSR规格手册可知从3位一直到168位LFSR均可选用4个及以下的抽头：</p>
<img src="/2019/12/03/Crypto-School/lSdFb9.png">
<p>所以优化之后最差情况下循环次数为<code>4</code>。也即单轮循环中所消耗的时间比为$\frac{4t_{inner} + t_{left}}{(n-1)t_{inner}+t_{left}}$。</p>
<p>在16位LFSR的测试中取得了近一倍的加速，而且随着选用的寄存器位数上升，加速效果越好。</p>
<h4 id="第二种优化"><a href="#第二种优化" class="headerlink" title="第二种优化"></a>第二种优化</h4><p>同时还提出另一种优化方法，利用分治的思想在比特位操作层面实现<code>tmp</code>中所有位的相互亦或：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> lfsr32(<span class="keyword">uint64_t</span> *reg, <span class="keyword">uint64_t</span> mask)&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> result = *reg &amp; <span class="number">0x1</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> tmp = *reg &amp; mask, lastbit = <span class="number">0</span>;</span><br><span class="line">	lastbit = (tmp &amp; <span class="number">0x5555555555555555</span>) ^ ((tmp &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>);</span><br><span class="line">	lastbit = (lastbit &amp; <span class="number">0x3333333333333333</span>) ^ ((lastbit &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>);</span><br><span class="line">	lastbit = (lastbit &amp; <span class="number">0x0F0F0F0F0F0F0F0F</span>) ^ ((lastbit &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F0F0F0F0F</span>);</span><br><span class="line">	lastbit = (lastbit &amp; <span class="number">0x00FF00FF00FF00FF</span>) ^ ((lastbit &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF00FF00FF</span>);</span><br><span class="line">	lastbit = (lastbit &amp; <span class="number">0x0000FFFF0000FFFF</span>) ^ ((lastbit &gt;&gt; <span class="number">16</span>)&amp; <span class="number">0x0000FFFF0000FFFF</span>);</span><br><span class="line">	lastbit = (lastbit &amp; <span class="number">0x00000000FFFFFFFF</span>) ^ ((lastbit &gt;&gt; <span class="number">32</span>)&amp; <span class="number">0x00000000FFFFFFFF</span>);</span><br><span class="line">	*reg = (lastbit &lt;&lt; (BITS - <span class="number">1</span>)) | (*reg &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法利用分治法枚举完了所有位互相亦或的结果，所花时间固定为$log_2{n}t_{inner} + t_{left}$，其中$n$为LFSR寄存器位数。在对于$log_2{n} &gt; 4$，也即16位LFSR之后应该体现不出性能优势。然而该种优化完全省去了循环中判断的过程，而对于现代处理器而言在不出现分支判断的情况下可以充分利用流水线。所以相较于上一种优化后仍存在循环处分支判断的方案，性能出现差距的位数被后移，直到42位差距才达到0.5秒且可反复测量。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ONE (1ULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITS (42)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> lfsr32(<span class="keyword">uint64_t</span> *reg, <span class="keyword">uint64_t</span> mask)&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> result = *reg &amp; <span class="number">0x1</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> tmp = *reg &amp; mask, lastbit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">		tmp &amp;= (tmp - <span class="number">1</span>);</span><br><span class="line">		lastbit ^= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*reg = (lastbit &lt;&lt; (BITS - <span class="number">1</span>)) | (*reg &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//unsigned MASK = (1 &lt;&lt; 22) | (1 &lt;&lt; 17); //x^32 + x^22 + x^2 + x^1 + 1</span></span><br><span class="line">	<span class="keyword">uint64_t</span> MASK = (ONE &lt;&lt; <span class="number">41</span>) | (ONE &lt;&lt; <span class="number">39</span>) | (ONE &lt;&lt; <span class="number">36</span>) | (ONE &lt;&lt; <span class="number">34</span>); </span><br><span class="line">	<span class="comment">//https://www.partow.net/programming/polynomials/index.html#deg31</span></span><br><span class="line">	<span class="comment">//https://web.archive.org/web/20161007061934/http://courses.cse.tamu.edu/csce680/walker/lfsr_table.pdf</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint64_t</span> INIT_REG = ONE;</span><br><span class="line">	<span class="keyword">uint64_t</span> REG = INIT_REG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> upper = ONE &lt;&lt; BITS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(; i &lt; upper; ++i)&#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> r = lfsr32(&amp;REG, MASK);</span><br><span class="line">		<span class="keyword">if</span>(INIT_REG == REG)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(i % (upper &gt;&gt; <span class="number">7</span>) == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.3lf \n"</span>, <span class="number">100.0</span>*i / upper);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i == upper)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">", right"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">", wrong"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p>第一种优化</p>
<blockquote>
<p>…</p>
<p>96.88</p>
<p>98.44</p>
<p>4398046511104, right</p>
<p>./lfsr 1413.45s user 0.01s system 99% cpu 23:34.82 total</p>
</blockquote>
<p>第二种优化</p>
<blockquote>
<p>…</p>
<p>96.88</p>
<p>98.44</p>
<p>4398046511104, right</p>
<p>./lfsr 1414.00s user 0.01s system 99% cpu 23:35.82 total</p>
</blockquote>
<h3 id="安全性分析-3"><a href="#安全性分析-3" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>LFSR的软件实现的性能在适当优化后很强，同时硬件实现几乎可以说是最快的。LFSR在选取正确的抽头并使用随机的初始寄存器状态时，生成的密钥会遍历整个$2^n-1$的空间。只要密钥序列不被泄露就很安全，所以要想办法避免攻击者取得明文-密文对，否则在得到足够长的密钥序列之后LFSR便不再安全。</p>
<h1 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h1><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>DES(Data Encryption Standard)是密码学历史上第一个广泛应用于商用数据保密的密码算法，并开创了公开密码算法的先例，极大地促进了密码学的发展。它分组长度 64 比特，密钥长度 64 比特（其中有效长度为 56 比特），8 的倍数位为奇校验位（保证每 8 位有奇数个 1）。</p>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="密钥编排算法"><a href="#密钥编排算法" class="headerlink" title="密钥编排算法"></a>密钥编排算法</h4><p>用于生成迭代的子密钥。具体过程为：</p>
<p>64位初始密钥经过置换选择1 ( PC-1 ) 后变成 56 位，经过循环左移和置换选择2 ( PC-2 ) 后分别得到 16 个 48 位子密钥 Ki用做每一轮的迭代运算。</p>
<p>置换选择1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Do the intial permutation for key</span></span><br><span class="line">tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; ++i)&#123;</span><br><span class="line">	tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	tmp |= (k &gt;&gt; (<span class="number">64</span> - PC1[i])) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br><span class="line">C = (tmp &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xfffffff</span>;</span><br><span class="line">D = tmp &amp; <span class="number">0xfffffff</span>;</span><br></pre></td></tr></table></figure>
<p>循环左移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; key_shift[i]; ++j)&#123;</span><br><span class="line">	C = ((C &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x0fffffff</span>) | ((C &gt;&gt; <span class="number">27</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">	D = ((D &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x0fffffff</span>) | ((D &gt;&gt; <span class="number">27</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">&#125;</span><br><span class="line">tmp = (C &lt;&lt; <span class="number">28</span>) | (D);</span><br></pre></td></tr></table></figure>
<h4 id="F函数"><a href="#F函数" class="headerlink" title="F函数"></a>F函数</h4><p>也称轮函数，包括四个过程：</p>
<ol>
<li><p>扩展置换 ( E 盒 )</p>
<p>通过扩展置换，数据的右半部分 Ri 从 32 位扩展到 48 位。扩展置换改变了位的次序，重复了某些位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">48</span>; ++j)&#123;</span><br><span class="line">	tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	tmp |= (R &gt;&gt; (<span class="number">32</span> - ebox[j])) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>密钥加</p>
<p>E 盒输出与子密钥 <strong>Xor</strong> （逐位异或）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mode == ENCRYPT)</span><br><span class="line">	tmp ^= key_list[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	tmp ^= key_list[<span class="number">15</span> - i];</span><br></pre></td></tr></table></figure>
</li>
<li><p>S 盒</p>
<p>实现非线性代换，是查表运算，8 个 S 盒对应把 48 位分成 8 个组（6 位一组）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Third, subtitle it with sbox</span></span><br><span class="line">s_result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)&#123;</span><br><span class="line">	tmp2 = ((tmp &amp; (<span class="number">0xfc0000000000</span> &gt;&gt; (<span class="number">6</span> * j))) &gt;&gt; (<span class="number">42</span> - <span class="number">6</span> * j));</span><br><span class="line">	uint8 row = ((tmp2 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x2</span>) | (tmp2 &amp; <span class="number">0x1</span>);</span><br><span class="line">	uint8 column = (tmp2 &amp; <span class="number">0x1e</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	s_result &lt;&lt;= <span class="number">4</span>;</span><br><span class="line">	s_result |= sbox[j][row * <span class="number">16</span> + column];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>P 盒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Fourth, replace operation</span></span><br><span class="line">p_result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)&#123;</span><br><span class="line">	p_result &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	p_result |= (s_result &gt;&gt; (<span class="number">32</span> - pbox[j])) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><p>省略替换表的数据，太多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//For standard x86-64 machine around 2020</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uint64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uint8;</span><br><span class="line"></span><br><span class="line">uint8 sbox[<span class="number">8</span>][<span class="number">4</span> * <span class="number">16</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 ebox[<span class="number">48</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 pbox[<span class="number">32</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 m_IP[<span class="number">64</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 m_PI[<span class="number">64</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 PC1[<span class="number">64</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 PC2[<span class="number">48</span>] = &#123;</span><br><span class="line">	<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>,  <span class="number">1</span>,  <span class="number">5</span>,</span><br><span class="line">     <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line">    <span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line">    <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">    <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">    <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 key_shift[<span class="number">16</span>] = &#123;</span><br><span class="line"> <span class="comment">/* 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16 */</span></span><br><span class="line">    <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> MODE &#123;</span><br><span class="line">	ENCRYPT,</span><br><span class="line">	DECRYPT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">des</span><span class="params">(uint64 message, uint64 key, <span class="keyword">int</span> mode)</span></span>&#123;</span><br><span class="line">	uint64 m = <span class="number">0</span>, k = <span class="number">0</span>, tmp, tmp2, L, R, C, D;</span><br><span class="line">	uint64 key_list[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	uint64 s_result, p_result;</span><br><span class="line">	m = message;</span><br><span class="line">	k = key;</span><br><span class="line"><span class="comment">//uint64 des(uint8 *message, uint8 *key, int mode)&#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	//copy message from char array to one unsigned 64-bits var</span></span><br><span class="line"><span class="comment">	for(unsigned i = 0; i &lt; 8; ++i)&#123;</span></span><br><span class="line"><span class="comment">		m &lt;&lt;= 8;</span></span><br><span class="line"><span class="comment">		m |= message[i];</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	//copy key from char array to one unsigned 64-bits var</span></span><br><span class="line"><span class="comment">	for(unsigned i = 0; i &lt; 8; ++i)&#123;</span></span><br><span class="line"><span class="comment">		k &lt;&lt;= 8;</span></span><br><span class="line"><span class="comment">		k |= key[i];</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Do the initial permutation for message</span></span><br><span class="line">	tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)&#123;</span><br><span class="line">		tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		tmp |= (m &gt;&gt; (<span class="number">64</span> - m_IP[i])) &amp; <span class="number">0x1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L = (tmp &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">	R = tmp &amp; <span class="number">0xffffffff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Do the intial permutation for key</span></span><br><span class="line">	tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">56</span>; ++i)&#123;</span><br><span class="line">		tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		tmp |= (k &gt;&gt; (<span class="number">64</span> - PC1[i])) &amp; <span class="number">0x1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	C = (tmp &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xfffffff</span>;</span><br><span class="line">	D = tmp &amp; <span class="number">0xfffffff</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Prepare all the keys for encryption precedure</span></span><br><span class="line">	<span class="comment">//Fill the key_list for following 16 round operations</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; key_shift[i]; ++j)&#123;</span><br><span class="line">			C = ((C &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x0fffffff</span>) | ((C &gt;&gt; <span class="number">27</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">			D = ((D &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0x0fffffff</span>) | ((D &gt;&gt; <span class="number">27</span>) &amp; <span class="number">0x1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = (C &lt;&lt; <span class="number">28</span>) | (D);</span><br><span class="line"></span><br><span class="line">		key_list[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">48</span>; ++j)&#123;</span><br><span class="line">			key_list[i] &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">			key_list[i] |= (tmp &gt;&gt; (<span class="number">56</span> - PC2[j])) &amp; <span class="number">0x1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Begin encryption rounds</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">		<span class="comment">//F funtion start</span></span><br><span class="line">		<span class="comment">//First, extend R part</span></span><br><span class="line">		tmp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">48</span>; ++j)&#123;</span><br><span class="line">			tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">			tmp |= (R &gt;&gt; (<span class="number">32</span> - ebox[j])) &amp; <span class="number">0x1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Second, xor it with key</span></span><br><span class="line">		<span class="keyword">if</span>(mode == ENCRYPT)</span><br><span class="line">			tmp ^= key_list[i];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tmp ^= key_list[<span class="number">15</span> - i];</span><br><span class="line">		<span class="comment">//Third, subtitle it with sbox</span></span><br><span class="line">		s_result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)&#123;</span><br><span class="line">			tmp2 = ((tmp &amp; (<span class="number">0xfc0000000000</span> &gt;&gt; (<span class="number">6</span> * j))) &gt;&gt; (<span class="number">42</span> - <span class="number">6</span> * j));</span><br><span class="line">			uint8 row = ((tmp2 &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x2</span>) | (tmp2 &amp; <span class="number">0x1</span>);</span><br><span class="line">			uint8 column = (tmp2 &amp; <span class="number">0x1e</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			s_result &lt;&lt;= <span class="number">4</span>;</span><br><span class="line">			s_result |= sbox[j][row * <span class="number">16</span> + column];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//Fourth, replace operation</span></span><br><span class="line">		p_result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)&#123;</span><br><span class="line">			p_result &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">			p_result |= (s_result &gt;&gt; (<span class="number">32</span> - pbox[j])) &amp; <span class="number">0x1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		tmp = R;</span><br><span class="line">		R = L ^ p_result;</span><br><span class="line">		L = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Combine L and R to get result</span></span><br><span class="line">	tmp = (R &lt;&lt; <span class="number">32</span>) | L;</span><br><span class="line">	<span class="comment">//Inverse the initial permuation</span></span><br><span class="line">	tmp2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)&#123;</span><br><span class="line">		tmp2 &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		tmp2 |= (tmp &gt;&gt; (<span class="number">64</span> - m_PI[i])) &amp; <span class="number">0x1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	uint64 m = <span class="number">0x02468aceeca86420</span>;</span><br><span class="line">	uint64 k = <span class="number">0x0f1571c947d9e859</span>;</span><br><span class="line">	uint64 res = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        	res = des(res, res, ENCRYPT);</span><br><span class="line">        	<span class="built_in">printf</span> (<span class="string">"E: %016llx\n"</span>, res);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	res = des(res, res, DECRYPT);</span><br><span class="line">        	<span class="built_in">printf</span> (<span class="string">"D: %016llx\n"</span>, res);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = des(m, k, ENCRYPT);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"E: %016llx\n"</span>, res);</span><br><span class="line"></span><br><span class="line">    res = des(res, k, DECRYPT);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"D: %016llx\n"</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/2019/12/03/Crypto-School/l9UJoR.png">
<h3 id="正确性分析-1"><a href="#正确性分析-1" class="headerlink" title="正确性分析"></a>正确性分析</h3><p>解密过程实际上就是加密过程的逆过程，在加密中，密钥编排算法中的循环移位是循环左移，则在解密中，使用循环右移，致使加密过程中每轮子密钥和解密过程中每轮子密钥顺序刚好相反。加密和解密过程满足：</p>
<p>$DESDecrypt(DESEncrypt(M))=M$</p>
<h3 id="安全性分析-4"><a href="#安全性分析-4" class="headerlink" title="安全性分析"></a>安全性分析</h3><h4 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h4><p>存在使得加密算法和解密算法没有区别的密钥。即有：$Ek(Ek(M))=Dk(Dk(M))=M$</p>
<p>这种密钥使得密钥编排算法中，CC 和 DD始终不变（全0或全1）。相应的，还有半弱密钥。</p>
<h4 id="互补性"><a href="#互补性" class="headerlink" title="互补性"></a>互补性</h4><p>若$ c=Ek(m)$则 $\overline{c}=E_{\overline{e}}(\overline{m})$，这使得在选择明文攻击下所需的工作量减半（从 $2^{56}$ 减少到 $2^{55}$ ）。</p>
<p>故而对于DES，现代一般选用3DES也即利用多重DES过程来进行加密，应用很广泛。</p>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>AES(Advanced Encryption Standard)是用来替换DES的加密算法标准，要求性能不低于3DES，安全性比3DES强，而且在世界范围内是可以免费获得的。它的分组长度为128位，而密钥长度可变，分别为：128，192或256位。加密轮数也有所不同，这里以AES128为准。</p>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="密钥拓展算法"><a href="#密钥拓展算法" class="headerlink" title="密钥拓展算法"></a>密钥拓展算法</h4><p>用于生成迭代的子密钥。具体过程为：</p>
<p>将128位密钥装入4x4矩阵中，然后通过递归过程对矩阵进行拓展得到10个4x4矩阵。</p>
<img src="/2019/12/03/Crypto-School/lCBP0S.jpg">
<p>如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyExpansion</span><span class="params">(uint8 *key, uint8 keyed[][<span class="number">4</span>][<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			keyed[<span class="number">0</span>][j][i] = key[i * <span class="number">4</span> + j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; <span class="number">4</span>; ++z)</span><br><span class="line">					keyed[i][z][j] = sbox[keyed[i<span class="number">-1</span>][(z + <span class="number">1</span>) % <span class="number">4</span>][<span class="number">3</span>]];</span><br><span class="line">				keyed[i][<span class="number">0</span>][j] ^= Rcon[i - <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; <span class="number">4</span>; ++z)</span><br><span class="line">					keyed[i][z][j] = keyed[i][z][j<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; <span class="number">4</span>; ++z)</span><br><span class="line">				keyed[i][z][j] ^= keyed[i - <span class="number">1</span>][z][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteSubtitle</span><span class="params">(uint8 *m, uint8 *box)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		unsigned row = m[i] &gt;&gt; 4;</span></span><br><span class="line"><span class="comment">		unsigned column = m[i] &amp; 0xf;</span></span><br><span class="line"><span class="comment">		m[i] = box[row * 16 + column];</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		m[i] = box[m[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteSubtitle</span><span class="params">(uint8 *m, uint8 *box)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		unsigned row = m[i] &gt;&gt; 4;</span></span><br><span class="line"><span class="comment">		unsigned column = m[i] &amp; 0xf;</span></span><br><span class="line"><span class="comment">		m[i] = box[row * 16 + column];</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		m[i] = box[m[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="列混淆"><a href="#列混淆" class="headerlink" title="列混淆"></a>列混淆</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">columnMix</span><span class="params">(uint8 *v)</span></span>&#123;</span><br><span class="line">	uint8 tmp[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			tmp[j] = v[j * <span class="number">4</span> + i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			v[j * <span class="number">4</span> + i] = gf2_8_multiply(mix_matrix[j][<span class="number">0</span>], tmp[<span class="number">0</span>]) ^</span><br><span class="line">						gf2_8_multiply(mix_matrix[j][<span class="number">1</span>], tmp[<span class="number">1</span>]) ^</span><br><span class="line">						gf2_8_multiply(mix_matrix[j][<span class="number">2</span>], tmp[<span class="number">2</span>]) ^</span><br><span class="line">						gf2_8_multiply(mix_matrix[j][<span class="number">3</span>], tmp[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<code>gf2_8_multiply</code>是在基于$GF(2^8)$上的二元运算，实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint8 <span class="title">gf2_8_multiply</span><span class="params">(uint8 a, uint8 b)</span></span>&#123;</span><br><span class="line">	uint8 acc = b, res = (a &amp; <span class="number">0x1</span>) ? b : <span class="number">0</span>;</span><br><span class="line">	a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(a)&#123;</span><br><span class="line">		<span class="keyword">if</span>(acc &amp; <span class="number">0x80</span>)</span><br><span class="line">			acc = (acc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x1b</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			acc &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a &amp; <span class="number">0x1</span>)</span><br><span class="line">			res ^= acc;</span><br><span class="line">		a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算过程即是利用如下结论：</p>
<img src="/2019/12/03/Crypto-School/formula2.png">
<h4 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h4><p>过程即是简单的xor</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Xor</span><span class="params">(uint8 *xored, uint8 *xorer)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">		xored[i] ^= xorer[i];</span><br><span class="line">&#125;<span class="function"><span class="keyword">void</span> <span class="title">Xor</span><span class="params">(uint8 *xored, uint8 *xorer)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">		xored[i] ^= xorer[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><p>省略替换表的数据，太多了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//For standard x86-64 machine around 2020</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uint64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uint8;</span><br><span class="line"></span><br><span class="line">uint8 sbox[<span class="number">256</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 invsbox[<span class="number">256</span>] = &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteSubtitle</span><span class="params">(uint8 *m, uint8 *box)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		unsigned row = m[i] &gt;&gt; 4;</span></span><br><span class="line"><span class="comment">		unsigned column = m[i] &amp; 0xf;</span></span><br><span class="line"><span class="comment">		m[i] = box[row * 16 + column];</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		m[i] = box[m[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftRow</span><span class="params">(uint8 *v)</span></span>&#123;</span><br><span class="line">	uint8 tmp[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			tmp[j] = v[i * <span class="number">4</span> + ((j + i) % <span class="number">4</span>)];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			v[i * <span class="number">4</span> + j] = tmp[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invShiftRow</span><span class="params">(uint8 *v)</span></span>&#123;</span><br><span class="line">	uint8 tmp[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			tmp[j] = v[i * <span class="number">4</span> + ((j - i + <span class="number">4</span>) % <span class="number">4</span>)];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			v[i * <span class="number">4</span> + j] = tmp[j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8 mix_matrix[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint8 inv_mix_matrix[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>, <span class="number">0xd</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span>, <span class="number">0xb</span>&#125;,</span><br><span class="line">	&#123;<span class="number">0xb</span>, <span class="number">0xd</span>, <span class="number">0x9</span>, <span class="number">0xe</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">uint8 <span class="title">gf2_8_multiply</span><span class="params">(uint8 a, uint8 b)</span></span>&#123;</span><br><span class="line">	uint8 acc = b, res = (a &amp; <span class="number">0x1</span>) ? b : <span class="number">0</span>;</span><br><span class="line">	a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(a)&#123;</span><br><span class="line">		<span class="keyword">if</span>(acc &amp; <span class="number">0x80</span>)</span><br><span class="line">			acc = (acc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x1b</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			acc &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a &amp; <span class="number">0x1</span>)</span><br><span class="line">			res ^= acc;</span><br><span class="line">		a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">columnMix</span><span class="params">(uint8 *v)</span></span>&#123;</span><br><span class="line">	uint8 tmp[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			tmp[j] = v[j * <span class="number">4</span> + i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			v[j * <span class="number">4</span> + i] = gf2_8_multiply(mix_matrix[j][<span class="number">0</span>], tmp[<span class="number">0</span>]) ^</span><br><span class="line">						gf2_8_multiply(mix_matrix[j][<span class="number">1</span>], tmp[<span class="number">1</span>]) ^</span><br><span class="line">						gf2_8_multiply(mix_matrix[j][<span class="number">2</span>], tmp[<span class="number">2</span>]) ^</span><br><span class="line">						gf2_8_multiply(mix_matrix[j][<span class="number">3</span>], tmp[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invColumnMix</span><span class="params">(uint8 *v)</span></span>&#123;</span><br><span class="line">	uint8 tmp[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			tmp[j] = v[j * <span class="number">4</span> + i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			v[j * <span class="number">4</span> + i] = gf2_8_multiply(inv_mix_matrix[j][<span class="number">0</span>], tmp[<span class="number">0</span>]) ^</span><br><span class="line">						gf2_8_multiply(inv_mix_matrix[j][<span class="number">1</span>], tmp[<span class="number">1</span>]) ^</span><br><span class="line">						gf2_8_multiply(inv_mix_matrix[j][<span class="number">2</span>], tmp[<span class="number">2</span>]) ^</span><br><span class="line">						gf2_8_multiply(inv_mix_matrix[j][<span class="number">3</span>], tmp[<span class="number">3</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Xor</span><span class="params">(uint8 *xored, uint8 *xorer)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">		xored[i] ^= xorer[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8 Rcon[<span class="number">10</span>] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1b</span>, <span class="number">0x36</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keyExpansion</span><span class="params">(uint8 *key, uint8 keyed[][<span class="number">4</span>][<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			keyed[<span class="number">0</span>][j][i] = key[i * <span class="number">4</span> + j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; <span class="number">4</span>; ++z)</span><br><span class="line">					keyed[i][z][j] = sbox[keyed[i<span class="number">-1</span>][(z + <span class="number">1</span>) % <span class="number">4</span>][<span class="number">3</span>]];</span><br><span class="line">				keyed[i][<span class="number">0</span>][j] ^= Rcon[i - <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; <span class="number">4</span>; ++z)</span><br><span class="line">					keyed[i][z][j] = keyed[i][z][j<span class="number">-1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> z = <span class="number">0</span>; z &lt; <span class="number">4</span>; ++z)</span><br><span class="line">				keyed[i][z][j] ^= keyed[i - <span class="number">1</span>][z][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_encrypt</span><span class="params">(uint8 *m, uint8 *key)</span></span>&#123;</span><br><span class="line">	uint8 state[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			state[i][j] = m[j * <span class="number">4</span> + i];</span><br><span class="line"></span><br><span class="line">	uint8 keyed[<span class="number">11</span>][<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">	keyExpansion(key, keyed);</span><br><span class="line"></span><br><span class="line">	Xor((uint8 *)state, (uint8 *)keyed[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)&#123;</span><br><span class="line">		byteSubtitle((uint8 *)state, sbox);</span><br><span class="line">		shiftRow((uint8 *)state);</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">10</span>)</span><br><span class="line">			columnMix((uint8 *)state);</span><br><span class="line">		Xor((uint8 *)state, (uint8 *)keyed[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			m[j * <span class="number">4</span> + i] = state[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aes_decrypt</span><span class="params">(uint8 *c, uint8 *key)</span></span>&#123;</span><br><span class="line">	uint8 state[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			state[i][j] = c[j * <span class="number">4</span> + i];</span><br><span class="line"></span><br><span class="line">	uint8 keyed[<span class="number">11</span>][<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line">	keyExpansion(key, keyed);</span><br><span class="line"></span><br><span class="line">	Xor((uint8 *)state, (uint8 *)keyed[<span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">		invShiftRow((uint8 *)state);</span><br><span class="line">		byteSubtitle((uint8 *)state, invsbox);</span><br><span class="line">		Xor((uint8 *)state, (uint8 *)keyed[i]);</span><br><span class="line">		<span class="keyword">if</span>(i)</span><br><span class="line">			invColumnMix((uint8 *)state);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)</span><br><span class="line">			c[j * <span class="number">4</span> + i] = state[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	uint8 key[<span class="number">16</span>] = &#123;</span><br><span class="line">		<span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x06</span>, <span class="number">0x07</span>,</span><br><span class="line">		<span class="number">0x08</span>, <span class="number">0x09</span>, <span class="number">0x0a</span>, <span class="number">0x0b</span>, <span class="number">0x0c</span>, <span class="number">0x0d</span>, <span class="number">0x0e</span>, <span class="number">0x0f</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	uint8 message[<span class="number">16</span>] = &#123;</span><br><span class="line">		<span class="number">0x00</span>, <span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>, <span class="number">0x44</span>, <span class="number">0x55</span>, <span class="number">0x66</span>, <span class="number">0x77</span>,</span><br><span class="line">		<span class="number">0x88</span>, <span class="number">0x99</span>, <span class="number">0xaa</span>, <span class="number">0xbb</span>, <span class="number">0xcc</span>, <span class="number">0xdd</span>, <span class="number">0xee</span>, <span class="number">0xff</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	aes_encrypt(message, key);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02x "</span>, message[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	aes_decrypt(message, key);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02x "</span>, message[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/2019/12/03/Crypto-School/lCD5qK.png">
<h3 id="正确性分析-2"><a href="#正确性分析-2" class="headerlink" title="正确性分析"></a>正确性分析</h3><p>解密过程实际上就是加密过程的逆过程，加密和解密过程满足：</p>
<p>$AESDecrypt(AESEncrypt(M))=M$</p>
<h3 id="安全性分析-5"><a href="#安全性分析-5" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>AES表现出足够的安全性，没有已知的攻击方法能攻击AES，同时AES所采用的实现方法非常利于防止能量攻击和计时攻击。</p>
<h1 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h1><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>RSA的安全性基于大整数分解的困难性。过程如下：</p>
<ol>
<li>选取两个安全大素数p和q(至少1024比特)。</li>
<li>计算乘积$n = p \times q$， $\phi(n) = (p - 1)(q - 1)$，其中$\phi(n)$为$n$的欧拉函数。</li>
<li>随机选择整数$e(1 &lt; e &lt; \phi(e)), gcd(e, \phi(n)) = 1$，作为公钥</li>
<li>计算私钥$d \equiv e^{-1} (mod \phi(n))$</li>
</ol>
<p>而加密过程是$c \equiv m^e (mod n)$</p>
<p>解密过程是$m \equiv c^d(mod n)$</p>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="大素数生成"><a href="#大素数生成" class="headerlink" title="大素数生成"></a>大素数生成</h4><p><strong>Miler-Rabin 算法</strong></p>
<p>Miller-Rabin 算法常用来判断一个大整数是否是素数，如果该算法判定一个数是合数，则这个数肯定是合数。Miller-Rabin 算法是一个概率算法，也就是说，若该算法判定一个大整数是素数，则该整数不是素数的概率很小。</p>
<p>Miller-Rabin 概率检测算法的理论基础是费马小定理,即设 n 是正奇整数，如果 n 是素数，则对于任意整数$b (1 &lt; b &lt; n-1)$，有$b^{n-1}≡1(mod n)$。该命题的逆命题为：若$b^{n-1}\equiv1(mod n)$不成立，则n是合数。但该命题的逆命题并不一定成立。即若$b^{n-1}\equiv1(mod n)$，n 可能是素数，也可能是合数。</p>
<p>简单来说，如果对整数$b (1 &lt; b &lt; n-1),（n, b）= 1$，使得$b^{n-1}\equiv1(mod n)$不成立，则 n 是合数，如果成立，则 n 可能是素数，也可能是合数，需要通过再找别的整数$b (1 &lt; b &lt; n-1)$，进行判断，只要有一种b不成立则为合数（注意可能两个字）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">        a, b = b, a%b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MilerTest</span><span class="params">(n, testTimes = <span class="number">80</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(testTimes):</span><br><span class="line">        tmp = random.randrange(<span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> gcd(tmp, n) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> pow(tmp, n<span class="number">-1</span>, n) != <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>其中<code>testTimes</code>为测试次数，次数越多，n为素数的概率越大，权衡之后根据网上所说设定为80.</p>
<h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">2048</span>)</span><br><span class="line">q = getPrime(<span class="number">2048</span>)</span><br><span class="line">n = p * q</span><br><span class="line">phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">d = gmpy2.invert(e ,phi_n)</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(raw_input())</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<p>解密过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<h3 id="攻击方法-1"><a href="#攻击方法-1" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="低加密指数攻击"><a href="#低加密指数攻击" class="headerlink" title="低加密指数攻击"></a>低加密指数攻击</h4><p>为了使加密高效，一般希望选取较小的加密指数 e ，但是 e 不能太小，否则容易遭到低加密指数攻击。</p>
<p>假设用户使用的密钥e = 3 。考虑到加密关系满足：$c \equiv m^3 (mod n)$</p>
<p>则有: $m^3  =c + k * n$</p>
<p>则: $m = \sqrt[3]{c+k*n}$</p>
<p>攻击者可以从小到大枚举 k ，依次开三次根，直到开出<strong>整数</strong>为止。</p>
<h4 id="低加密指数广播攻击"><a href="#低加密指数广播攻击" class="headerlink" title="低加密指数广播攻击"></a>低加密指数广播攻击</h4><p>还有一种情况是如果给 k 个用户发的都是同个低加密指数比如 e=3，在不同的模数 n1.n2,n3下 ，可由 CRT（中国剩余定理） 解出$m^3$，从而直接开三次根解出 m，比赛考了很多次了。</p>
<h3 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h3><p>RSA基于大数分解问题，必然涉及大量的大数运算，故而效率比对称密码如DES，AES要低。在实现上<strong>Miler-Rabin</strong>所消耗的时间不确定。同时加密和解密中常用的<code>pow</code>函数通过优化之后即使时间复杂度为$O(log_2(min(a, b)))$，但是其中的计算依旧是大数运算，很耗时间。</p>
<p>非对称加密算法中 <strong>1024 bit</strong> 密钥的强度相当于对称加密算法 <strong>80bit</strong> 密钥的强度。但是，从效率上，密钥长度增长一倍，公钥操作所需时间增加约 4 倍，私钥操作所需时间增加约 8 倍，公私钥生成时间约增长16倍。</p>
<h3 id="安全性分析-6"><a href="#安全性分析-6" class="headerlink" title="安全性分析"></a>安全性分析</h3><p>RSA 基于大数因数分解的困难性，前人已经提出了二次筛因子分解法、椭圆曲线因子分解法、数域筛因子分解法等。但是，因数分解的复杂性并没有降到多项式水平，所以短时间内仍无法破译。当大整数因数分解难题被攻破或量子计算机普及之日，RSA 将不再安全。</p>
<p>现今采用RSA的系统被攻破往往是因为不当的使用方法，不如密钥过短，e过小这种情况。所以在使用时要经过严格的安全审计，或者使用成熟并验证过的现有实现来规避危险。</p>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>MD5由美国麻省理工学院的Rivest设计，该算法接受长度小于$2^{64}$比特的消息，输出长度为128比特的信息摘要。</p>
<h3 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h3><p>要注意MD5的上下文规定了是小端序，所以给出两个函数方便进行转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">to_bytes</span><span class="params">(uint8 *v, uint32 val)</span></span>&#123;</span><br><span class="line">	v[<span class="number">0</span>] = (uint8)val &amp; <span class="number">0xff</span>;</span><br><span class="line">	v[<span class="number">1</span>] = (uint8)(val &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	v[<span class="number">2</span>] = (uint8)(val &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	v[<span class="number">3</span>] = (uint8)(val &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint32 <span class="title">to_uint32</span><span class="params">(uint8 *bytes)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (uint32)bytes[<span class="number">0</span>] | </span><br><span class="line">			(((uint32)bytes[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">			(((uint32)bytes[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">			(((uint32)bytes[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h4><p>首先对于输入进行填充，满足长度模512与448同余，为的是提供64的空间用来存储消息的实际长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> new_len;</span><br><span class="line"><span class="keyword">for</span>(new_len = len + <span class="number">1</span>; new_len % (<span class="number">512</span> / <span class="number">8</span>) != <span class="number">448</span> / <span class="number">8</span>; ++new_len) &#123;&#125;</span><br><span class="line"></span><br><span class="line">uint8 *msg = (uint8 *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(uint8) * (new_len + <span class="number">8</span>));</span><br><span class="line"><span class="built_in">memcpy</span>(msg, m, len);</span><br><span class="line">msg[len] = <span class="number">0x80</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> i = len + <span class="number">1</span>; i &lt; new_len; ++i)</span><br><span class="line">	msg[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">to_bytes(&amp;msg[new_len], len * <span class="number">8</span>);</span><br><span class="line">to_bytes(&amp;msg[new_len + <span class="number">4</span>], len &gt;&gt; <span class="number">29</span>); <span class="comment">// &gt;&gt; 32 * 8</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化链接变量"><a href="#初始化链接变量" class="headerlink" title="初始化链接变量"></a>初始化链接变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint32 A = <span class="number">0x67452301</span>;</span><br><span class="line">uint32 B = <span class="number">0xefcdab89</span>;</span><br><span class="line">uint32 C = <span class="number">0x98badcfe</span>;</span><br><span class="line">uint32 D = <span class="number">0x10325476</span>;</span><br></pre></td></tr></table></figure>
<p>这里的变量看起来和课本上的不一样，实际上是经过了<code>to_bytes</code>函数完成小端序转换之后。</p>
<h4 id="循环过程"><a href="#循环过程" class="headerlink" title="循环过程"></a>循环过程</h4><img src="/2019/12/03/Crypto-School/300px-MD5_algorithm.svg.png">
<p>每一步中完成上图的操作，可以得到：变量D赋给变量A，变量B赋给变量C，变量C赋给变量D，而变量B由变量A与非线性函数结果相加，再与Mi，Ki相加，最后循环左移s位与B相加所得。</p>
<p>非线性函数如下：</p>
<img src="/2019/12/03/Crypto-School/FWCfGn.png">
<p>在C中用宏完成定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(X, Y, Z) (((X) &amp; (Y)) | (~(X) &amp; (Z)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(X, Y, Z) (((X) &amp; (Z)) | ((Y) &amp; ~(Z)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H(X, Y, Z) ((X) ^ (Y) ^ (Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I(X, Y, Z) ((Y) ^ ((X) | ~(Z)))</span></span><br></pre></td></tr></table></figure>
<p>Mi是来自消息的32bit子分组，Ki是一个伪随机的常数，用来消除输入数据的规律性。</p>
<p>而循环左移次数由MD5算法所规定，左移过程同样用宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LROTATE(x, n) (((x) <span class="meta-string">&lt;&lt; (n)) | ((x) &gt;&gt; (32 - (n))))</span></span></span><br></pre></td></tr></table></figure>
<p>完成全部迭代之后根据小端序还原即可得到结果</p>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//For standard x86-64 machine around 2020</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> uint64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uint8;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(X, Y, Z) (((X) &amp; (Y)) | (~(X) &amp; (Z)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(X, Y, Z) (((X) &amp; (Z)) | ((Y) &amp; ~(Z)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H(X, Y, Z) ((X) ^ (Y) ^ (Z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I(X, Y, Z) ((Y) ^ ((X) | ~(Z)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LROTATE(x, n) (((x) <span class="meta-string">&lt;&lt; (n)) | ((x) &gt;&gt; (32 - (n))))</span></span></span><br><span class="line"></span><br><span class="line">uint32 t[<span class="number">64</span>] = &#123;</span><br><span class="line">	<span class="number">0xd76aa478</span>, <span class="number">0xe8c7b756</span>, <span class="number">0x242070db</span>, <span class="number">0xc1bdceee</span>,</span><br><span class="line">	<span class="number">0xf57c0faf</span>, <span class="number">0x4787c62a</span>, <span class="number">0xa8304613</span>, <span class="number">0xfd469501</span>,</span><br><span class="line">	<span class="number">0x698098d8</span>, <span class="number">0x8b44f7af</span>, <span class="number">0xffff5bb1</span>, <span class="number">0x895cd7be</span>,</span><br><span class="line">	<span class="number">0x6b901122</span>, <span class="number">0xfd987193</span>, <span class="number">0xa679438e</span>, <span class="number">0x49b40821</span>,</span><br><span class="line">	<span class="number">0xf61e2562</span>, <span class="number">0xc040b340</span>, <span class="number">0x265e5a51</span>, <span class="number">0xe9b6c7aa</span>,</span><br><span class="line">	<span class="number">0xd62f105d</span>, <span class="number">0x02441453</span>, <span class="number">0xd8a1e681</span>, <span class="number">0xe7d3fbc8</span>,</span><br><span class="line">	<span class="number">0x21e1cde6</span>, <span class="number">0xc33707d6</span>, <span class="number">0xf4d50d87</span>, <span class="number">0x455a14ed</span>,</span><br><span class="line">	<span class="number">0xa9e3e905</span>, <span class="number">0xfcefa3f8</span>, <span class="number">0x676f02d9</span>, <span class="number">0x8d2a4c8a</span>,</span><br><span class="line">	<span class="number">0xfffa3942</span>, <span class="number">0x8771f681</span>, <span class="number">0x6d9d6122</span>, <span class="number">0xfde5380c</span>,</span><br><span class="line">	<span class="number">0xa4beea44</span>, <span class="number">0x4bdecfa9</span>, <span class="number">0xf6bb4b60</span>, <span class="number">0xbebfbc70</span>,</span><br><span class="line">	<span class="number">0x289b7ec6</span>, <span class="number">0xeaa127fa</span>, <span class="number">0xd4ef3085</span>, <span class="number">0x04881d05</span>,</span><br><span class="line">	<span class="number">0xd9d4d039</span>, <span class="number">0xe6db99e5</span>, <span class="number">0x1fa27cf8</span>, <span class="number">0xc4ac5665</span>,</span><br><span class="line">	<span class="number">0xf4292244</span>, <span class="number">0x432aff97</span>, <span class="number">0xab9423a7</span>, <span class="number">0xfc93a039</span>,</span><br><span class="line">	<span class="number">0x655b59c3</span>, <span class="number">0x8f0ccc92</span>, <span class="number">0xffeff47d</span>, <span class="number">0x85845dd1</span>,</span><br><span class="line">	<span class="number">0x6fa87e4f</span>, <span class="number">0xfe2ce6e0</span>, <span class="number">0xa3014314</span>, <span class="number">0x4e0811a1</span>,</span><br><span class="line">	<span class="number">0xf7537e82</span>, <span class="number">0xbd3af235</span>, <span class="number">0x2ad7d2bb</span>, <span class="number">0xeb86d391</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uint32 s[] = &#123;</span><br><span class="line">	<span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">22</span>,</span><br><span class="line">	<span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">5</span>,  <span class="number">9</span>, <span class="number">14</span>, <span class="number">20</span>,</span><br><span class="line">	<span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">23</span>,</span><br><span class="line">	<span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">to_bytes</span><span class="params">(uint8 *v, uint32 val)</span></span>&#123;</span><br><span class="line">	v[<span class="number">0</span>] = (uint8)val &amp; <span class="number">0xff</span>;</span><br><span class="line">	v[<span class="number">1</span>] = (uint8)(val &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	v[<span class="number">2</span>] = (uint8)(val &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	v[<span class="number">3</span>] = (uint8)(val &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint32 <span class="title">to_uint32</span><span class="params">(uint8 *bytes)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (uint32)bytes[<span class="number">0</span>] | </span><br><span class="line">			(((uint32)bytes[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">			(((uint32)bytes[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">			(((uint32)bytes[<span class="number">3</span>]) &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">md5</span><span class="params">(uint8 *m, <span class="keyword">unsigned</span> len, uint8 *hash)</span></span>&#123;</span><br><span class="line">	uint32 A = <span class="number">0x67452301</span>;</span><br><span class="line">	uint32 B = <span class="number">0xefcdab89</span>;</span><br><span class="line">	uint32 C = <span class="number">0x98badcfe</span>;</span><br><span class="line">	uint32 D = <span class="number">0x10325476</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> new_len;</span><br><span class="line">	<span class="keyword">for</span>(new_len = len + <span class="number">1</span>; new_len % (<span class="number">512</span> / <span class="number">8</span>) != <span class="number">448</span> / <span class="number">8</span>; ++new_len) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	uint8 *msg = (uint8 *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(uint8) * (new_len + <span class="number">8</span>));</span><br><span class="line">	<span class="built_in">memcpy</span>(msg, m, len);</span><br><span class="line">	msg[len] = <span class="number">0x80</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = len + <span class="number">1</span>; i &lt; new_len; ++i)</span><br><span class="line">		msg[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	to_bytes(&amp;msg[new_len], len * <span class="number">8</span>);</span><br><span class="line">	to_bytes(&amp;msg[new_len + <span class="number">4</span>], len &gt;&gt; <span class="number">29</span>); <span class="comment">// &gt;&gt; 32 * 8</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; new_len; i += (<span class="number">512</span> / <span class="number">8</span>))&#123;</span><br><span class="line">		uint32 state[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; ++j)</span><br><span class="line">			state[j] = to_uint32(msg + i + j * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> AA = A, BB = B, CC = C, DD = D, J, f;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j &lt; <span class="number">16</span>)&#123;</span><br><span class="line">				f = F(BB, CC, DD);</span><br><span class="line">				J = j;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; <span class="number">32</span>)&#123;</span><br><span class="line">				f = G(BB, CC, DD);</span><br><span class="line">				J = (<span class="number">5</span> * j + <span class="number">1</span>) % <span class="number">16</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &lt; <span class="number">48</span>)&#123;</span><br><span class="line">				f = H(BB, CC, DD);</span><br><span class="line">				J = (<span class="number">3</span> * j + <span class="number">5</span>) % <span class="number">16</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">				f = I(BB, CC, DD);</span><br><span class="line">				J = (<span class="number">7</span> * j) % <span class="number">16</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			uint32 tmp = DD;</span><br><span class="line">			DD = CC;</span><br><span class="line">			CC = BB;</span><br><span class="line">			BB += LROTATE(AA + f + t[j] + state[J], s[j]);</span><br><span class="line">			AA = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		A += AA;</span><br><span class="line">		B += BB;</span><br><span class="line">		C += CC;</span><br><span class="line">		D += DD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(msg);</span><br><span class="line"></span><br><span class="line">	to_bytes(hash, A);</span><br><span class="line">	to_bytes(hash + <span class="number">4</span>, B);</span><br><span class="line">	to_bytes(hash + <span class="number">8</span>, C);</span><br><span class="line">	to_bytes(hash + <span class="number">12</span>, D);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">	uint8 res[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	md5(argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]), res);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2.2x"</span>, res[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h3><img src="/2019/12/03/Crypto-School/lC5ZOe.png">
<p>与在线加密的结果一致</p>
<img src="/2019/12/03/Crypto-School/FoCnxJ.png">
<h3 id="安全性和效率分析"><a href="#安全性和效率分析" class="headerlink" title="安全性和效率分析"></a>安全性和效率分析</h3><p>MD5的在测试机上只需要10秒就可以计算完一个500MiB大小的文件的hash值(文件读取不成为瓶颈时)，性能可以接受。</p>
<p>因MD5能够接受的文件大小是$2^{64}$而输出的hash值仅为128位，故必然存在哈希碰撞的问题。现在网上有不少提供反向查询的数据库，通过建立存储有明文-密文对的数据库并查询来得到原象。但是这种攻击的应用场景依然有限，很多时候可以通过加盐来进行保护，故而安全性依旧可以接受在web开发中被广泛使用。</p>
<h1 id="综合实验"><a href="#综合实验" class="headerlink" title="综合实验"></a>综合实验</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>Alice想通过<strong>公共信道</strong>给Bob传输一份<strong>机密文件</strong>（<strong>文件非常大</strong>），又知道，<strong>很多人和机构想得到这份文件</strong>。如果你是Alice，你应该怎样做？</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>因为要传输的文件非常大，所以选用AES-CBC完成文件传输，平衡安全性和效率。但是如果想做到一次一密这样的理想状态，我们需要建立一个能够用来传送密钥的可信通道。想要建立这样一个可信通道，我选用公钥密码体制来实现，这里用RSA。同时为了防止机构在文件传输中进行篡改，需要对传送的文件的完整性有所保障。这里选用HASH函数配合RSA签名的方案。</p>
<p>详细如下：</p>
<ol>
<li><p>Alice 随机生成两个大素数 $p$ 和 $q$ ，计算 $n=p⋅q$ 和 $φ(n)=(p−1)⋅(q−1)$ ，接着计算 $d≡e−1(modφ(n))$ 计算完成后最好立即销毁 $p$,$q$,$φ(n)$，并且确保 $d$ 保密。</p>
</li>
<li><p>Alice 将公钥 $(n,e)$ 发送给 Bob。因为可能存在中间人 Eve ，Bob 需要确定收到的公钥真的是Alice的，这里选择在中立可信的第三方网站上发布自己的公钥，让网站给公钥背书。</p>
</li>
<li><p>Bob随机生成一个长度满足要求的密钥并用Alice的公钥加密发送给Alice。</p>
</li>
<li><p>Alice解密得到这一轮密钥，用AES-CBC对文件进行加密，并把文件的HASH值用自己的私钥签名。加到加密内容的后面发送给Bob。</p>
</li>
<li><p>Bob接收到之后进行解密，用解密得到的明文计算HASH值和签名的HASH值进行比较，如果相等则接受这份文件，否则拒绝并断开连接。</p>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>密钥生成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">()</span>:</span></span><br><span class="line">    p = getPrime(<span class="number">2048</span>)</span><br><span class="line">    q = getPrime(<span class="number">2048</span>)</span><br><span class="line">    n = p * q</span><br><span class="line">    phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">    d = gmpy2.invert(e ,phi_n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (n, e, d)</span><br></pre></td></tr></table></figure>
<p>规定p和q的长度为2048bit，应该够用。</p>
<p>AES-CBC所用密钥生成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key = os.urandom(<span class="number">16</span>)</span><br><span class="line">iv = os.urandom(<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>从系统的随机数生成器中获取16*8 = 128bit随机值。</p>
<p>接收端做签名验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = aes.decrypt(cipher)</span><br><span class="line">        hashsum = r.recv(<span class="number">512</span>)</span><br><span class="line">        hashsum = long_to_bytes(encrypt(bytes_to_long(hashsum), e, nn))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hashsum == sha1(message):</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> Crypto.Cipher.AES</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sha1</span><span class="params">(x)</span>:</span></span><br><span class="line">    m = hashlib.sha1()</span><br><span class="line">    m.update(x)</span><br><span class="line">    <span class="keyword">return</span> m.digest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">()</span>:</span></span><br><span class="line">    p = getPrime(<span class="number">2048</span>)</span><br><span class="line">    q = getPrime(<span class="number">2048</span>)</span><br><span class="line">    n = p * q</span><br><span class="line">    phi_n = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line">    d = gmpy2.invert(e ,phi_n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (n, e, d)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(m, e, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pow(m, e, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c, d, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pow(c, d, n)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ind = raw_input(<span class="string">"Am I server / client? [s/c]: "</span>).lower()</span><br><span class="line">    <span class="keyword">if</span> ind.strip() == <span class="string">'s'</span>:</span><br><span class="line">        port = int(raw_input(<span class="string">"Port number: "</span>))</span><br><span class="line">        l = listen(port)</span><br><span class="line">        r = l.wait_for_connection()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ip = raw_input(<span class="string">"Server ip: "</span>).strip()</span><br><span class="line">        port = int(raw_input(<span class="string">"Port number: "</span>))</span><br><span class="line">        r = remote(ip, port)</span><br><span class="line"></span><br><span class="line">    (n, e, d) = genkey()</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">"Generate n: "</span> + str(n))</span><br><span class="line">    log.success(<span class="string">"Generate e: "</span> + str(e))</span><br><span class="line">    log.success(<span class="string">"Generate d: "</span> + str(d))</span><br><span class="line"></span><br><span class="line">    r.send(long_to_bytes(n))</span><br><span class="line"></span><br><span class="line">    nn = bytes_to_long(r.recv(<span class="number">512</span>))</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">"Get n from another side: "</span> + str(nn))</span><br><span class="line"></span><br><span class="line">    ind = raw_input(<span class="string">"Send file? [y/n]: "</span>).lower()</span><br><span class="line">    <span class="keyword">if</span> ind.strip() == <span class="string">'y'</span>:</span><br><span class="line">        key = os.urandom(<span class="number">16</span>)</span><br><span class="line">        iv = os.urandom(<span class="number">16</span>)</span><br><span class="line">        log.success(<span class="string">"Generate key: "</span> + str(key))</span><br><span class="line">        log.success(<span class="string">"Generate iv: "</span> + str(iv))</span><br><span class="line">        r.send(long_to_bytes(encrypt(bytes_to_long(key), e, nn)))</span><br><span class="line">        r.send(long_to_bytes(encrypt(bytes_to_long(iv), e, nn)))</span><br><span class="line"></span><br><span class="line">        aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line">        message = <span class="string">"test"</span></span><br><span class="line">        length = <span class="number">16</span> - (len(message) % <span class="number">16</span>)</span><br><span class="line">        message += chr(length)*length</span><br><span class="line"></span><br><span class="line">        cipher = aes.encrypt(message)</span><br><span class="line">        r.sendline(str(len(cipher)))</span><br><span class="line">        r.send(cipher)</span><br><span class="line">        r.send(long_to_bytes(encrypt(bytes_to_long(sha1(message)), d, n)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key = bytes_to_long(r.recv(<span class="number">512</span>))</span><br><span class="line">        iv = bytes_to_long(r.recv(<span class="number">512</span>))</span><br><span class="line">        key = long_to_bytes(decrypt(key, d, n))</span><br><span class="line">        iv = long_to_bytes(decrypt(iv, d, n))</span><br><span class="line">        log.success(<span class="string">"Get key used in this round: "</span> + str(key))</span><br><span class="line">        log.success(<span class="string">"Get iv used in this round: "</span> + str(iv))</span><br><span class="line"></span><br><span class="line">        aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">        length = int(r.recvuntil(<span class="string">'\n'</span>))</span><br><span class="line">        cipher = r.recv(length)</span><br><span class="line">        message = aes.decrypt(cipher)</span><br><span class="line">        hashsum = r.recv(<span class="number">512</span>)</span><br><span class="line">        hashsum = long_to_bytes(encrypt(bytes_to_long(hashsum), e, nn))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hashsum == sha1(message):</span><br><span class="line">            <span class="comment"># remove the padding</span></span><br><span class="line">            message = message[:-ord(message[<span class="number">-1</span>])]</span><br><span class="line">            log.success(message)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Verify checksum failed, please be careful!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p>服务端：</p>
<img src="/2019/12/03/Crypto-School/lAiytJ.png">
<p>客户端：</p>
<img src="/2019/12/03/Crypto-School/lAi6h9.png">

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/23/LingHang2019/" rel="next" title="LingHang2019">
                <i class="fa fa-chevron-left"></i> LingHang2019
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/20/MOBISEC/" rel="prev" title="MOBISEC">
                MOBISEC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">FX-Ti</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">186</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://iv4n.xyz/" title="iv4n" target="_blank">iv4n</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://qsang.xin/" title="姜姜酱" target="_blank">姜姜酱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://3nd.xyz/" title="3ND" target="_blank">3ND</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#学校课程设涉及到的加密学算法实现"><span class="nav-number">1.</span> <span class="nav-text">学校课程设涉及到的加密学算法实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#古典密码"><span class="nav-number">2.</span> <span class="nav-text">古典密码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#凯撒密码"><span class="nav-number">2.1.</span> <span class="nav-text">凯撒密码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加密实现"><span class="nav-number">2.1.1.</span> <span class="nav-text">加密实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解密实现"><span class="nav-number">2.1.2.</span> <span class="nav-text">解密实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#针对凯撒的攻击"><span class="nav-number">2.1.3.</span> <span class="nav-text">针对凯撒的攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#暴力枚举"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">暴力枚举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析"><span class="nav-number">2.1.4.</span> <span class="nav-text">安全性分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#仿射密码"><span class="nav-number">2.2.</span> <span class="nav-text">仿射密码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加密实现-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">加密实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解密实现-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">解密实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#针对仿射的攻击"><span class="nav-number">2.2.3.</span> <span class="nav-text">针对仿射的攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#穷举攻击"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">穷举攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#统计分析攻击"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">统计分析攻击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析-1"><span class="nav-number">2.2.4.</span> <span class="nav-text">安全性分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#维吉尼亚密码"><span class="nav-number">2.3.</span> <span class="nav-text">维吉尼亚密码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加密实现-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">加密实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解密实现-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">解密实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#攻击方法"><span class="nav-number">2.3.3.</span> <span class="nav-text">攻击方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析-2"><span class="nav-number">2.3.4.</span> <span class="nav-text">安全性分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流密码"><span class="nav-number">3.</span> <span class="nav-text">流密码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RC4"><span class="nav-number">3.1.</span> <span class="nav-text">RC4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法实现"><span class="nav-number">3.1.1.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#密钥调度算法"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">密钥调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#伪随机生成算法"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">伪随机生成算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整代码"><span class="nav-number">3.1.2.</span> <span class="nav-text">完整代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行结果"><span class="nav-number">3.1.3.</span> <span class="nav-text">运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确性分析"><span class="nav-number">3.1.4.</span> <span class="nav-text">正确性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性"><span class="nav-number">3.1.5.</span> <span class="nav-text">安全性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LFSR"><span class="nav-number">3.2.</span> <span class="nav-text">LFSR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法实现-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">算法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#m序列密码的破译"><span class="nav-number">3.2.2.</span> <span class="nav-text">m序列密码的破译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证生成序列的周期"><span class="nav-number">3.2.3.</span> <span class="nav-text">验证生成序列的周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一种优化"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">第一种优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二种优化"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">第二种优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现代码"><span class="nav-number">3.2.4.</span> <span class="nav-text">实现代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行结果-1"><span class="nav-number">3.2.5.</span> <span class="nav-text">运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析-3"><span class="nav-number">3.2.6.</span> <span class="nav-text">安全性分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分组密码"><span class="nav-number">4.</span> <span class="nav-text">分组密码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DES"><span class="nav-number">4.1.</span> <span class="nav-text">DES</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法实现-2"><span class="nav-number">4.1.1.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#密钥编排算法"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">密钥编排算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#F函数"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">F函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整代码-1"><span class="nav-number">4.1.2.</span> <span class="nav-text">完整代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确性分析-1"><span class="nav-number">4.1.3.</span> <span class="nav-text">正确性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析-4"><span class="nav-number">4.1.4.</span> <span class="nav-text">安全性分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#弱密钥"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">弱密钥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互补性"><span class="nav-number">4.1.4.2.</span> <span class="nav-text">互补性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AES"><span class="nav-number">4.2.</span> <span class="nav-text">AES</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法实现-3"><span class="nav-number">4.2.1.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#密钥拓展算法"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">密钥拓展算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节代换"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">字节代换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行移位"><span class="nav-number">4.2.1.3.</span> <span class="nav-text">行移位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列混淆"><span class="nav-number">4.2.1.4.</span> <span class="nav-text">列混淆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轮密钥加"><span class="nav-number">4.2.1.5.</span> <span class="nav-text">轮密钥加</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整代码-2"><span class="nav-number">4.2.2.</span> <span class="nav-text">完整代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正确性分析-2"><span class="nav-number">4.2.3.</span> <span class="nav-text">正确性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析-5"><span class="nav-number">4.2.4.</span> <span class="nav-text">安全性分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#公钥密码"><span class="nav-number">5.</span> <span class="nav-text">公钥密码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RSA"><span class="nav-number">5.1.</span> <span class="nav-text">RSA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法实现-4"><span class="nav-number">5.1.1.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#大素数生成"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">大素数生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加密过程"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">加密过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#攻击方法-1"><span class="nav-number">5.1.2.</span> <span class="nav-text">攻击方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#低加密指数攻击"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">低加密指数攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#低加密指数广播攻击"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">低加密指数广播攻击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#效率分析"><span class="nav-number">5.1.3.</span> <span class="nav-text">效率分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性分析-6"><span class="nav-number">5.1.4.</span> <span class="nav-text">安全性分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希函数"><span class="nav-number">6.</span> <span class="nav-text">哈希函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MD5"><span class="nav-number">6.1.</span> <span class="nav-text">MD5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法实现-5"><span class="nav-number">6.1.1.</span> <span class="nav-text">算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Padding"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">Padding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化链接变量"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">初始化链接变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环过程"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">循环过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现代码-1"><span class="nav-number">6.1.2.</span> <span class="nav-text">实现代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行结果-2"><span class="nav-number">6.1.3.</span> <span class="nav-text">运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全性和效率分析"><span class="nav-number">6.1.4.</span> <span class="nav-text">安全性和效率分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#综合实验"><span class="nav-number">7.</span> <span class="nav-text">综合实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#需求"><span class="nav-number">7.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计"><span class="nav-number">7.2.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现"><span class="nav-number">7.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行截图"><span class="nav-number">7.4.</span> <span class="nav-text">运行截图</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FX-Ti</span>

  

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
